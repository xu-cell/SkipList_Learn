- c++11中的多线程锁的使用：为了解决线程之间互相抢夺资源。 在跳表的添加元素与删除元素中都使用了互斥锁。查询文章的解释：互斥锁是一个可锁定的对象，当代码的关键部分需要独占访问时，互斥锁会发出信号，**防止具有相同保护的其他线程并发执行并访问相同的内存位置。** 其中lock和unlock函数必须是成对出现的，如果忘记unlock函数没有写，将会操作程序发生死锁，无法继续运行。；互斥量用于组成代码的临界区。C++的多线程模型是基于内存的，或者说是基于代码片段的，这和我们操作系统学习的临界区概念基本一致，但是与Golang不同，Golang是基于消息模型的。
一个std::mutex的lock()和unlock()之间的代码片段组成一个临界区，这个临界区内部同时最多只能有一个线程进行访问，可以理解为这个片段内部的代码是受到保护的，不会被多线程同时访问造成不可预知的问题
